"use strict";exports.id=487,exports.ids=[487],exports.modules={19204:(e,t,s)=>{s.d(t,{V:()=>r});let r="io.prismic.preview"},44640:(e,t,s)=>{s.d(t,{u:()=>n});var r=s(44512),i=s(19204);let a=e=>"object"==typeof e&&null!==e&&"ref"in e,n=e=>{"previewData"in e&&e.previewData?a(e.previewData)&&e.client.queryContentFromRef(e.previewData.ref):"req"in e&&e.req?e.client.enableAutoPreviewsFromReq(e.req):e.client.queryContentFromRef(async()=>{var e;let t;let s=!1;try{s=(await (0,r.rQ)()).isEnabled}catch{return}if(s){try{t=null==(e=(await (0,r.UL)()).get(i.V))?void 0:e.value}catch{return}if(t&&/\.prismic\.io/.test(t))return t}})}},26003:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var s in t)Object.defineProperty(e,s,{enumerable:!0,get:t[s]})}(t,{HTTPAccessErrorStatus:function(){return s},HTTP_ERROR_FALLBACK_ERROR_CODE:function(){return i},getAccessFallbackErrorTypeByStatus:function(){return o},getAccessFallbackHTTPStatus:function(){return n},isHTTPAccessFallbackError:function(){return a}});let s={NOT_FOUND:404,FORBIDDEN:403,UNAUTHORIZED:401},r=new Set(Object.values(s)),i="NEXT_HTTP_ERROR_FALLBACK";function a(e){if("object"!=typeof e||null===e||!("digest"in e)||"string"!=typeof e.digest)return!1;let[t,s]=e.digest.split(";");return t===i&&r.has(Number(s))}function n(e){return Number(e.digest.split(";")[1])}function o(e){switch(e){case 401:return"unauthorized";case 403:return"forbidden";case 404:return"not-found";default:return}}("function"==typeof t.default||"object"==typeof t.default&&null!==t.default)&&void 0===t.default.__esModule&&(Object.defineProperty(t.default,"__esModule",{value:!0}),Object.assign(t.default,t),e.exports=t.default)},15212:(e,t,s)=>{s.d(t,{U:()=>en});let r=e=>Array.isArray(e)?e:[e],i=(e={},t)=>({...e,filters:[...e.filters||[],...r(t)]}),a=e=>"function"==typeof e?e:()=>e,n="7.15.1",o=e=>`https://prismic.dev/msg/client/v${n}/${e}`,l=e=>Array.isArray(e)?`[${e.map(l).join(", ")}]`:"string"==typeof e?`"${e}"`:e instanceof Date?`${e.getTime()}`:`${e}`,h=e=>(t,...s)=>{let r=s.map(l).join(", "),i=t&&s.length?", ":"";return`[${e}(${t}${i}${r})]`},u=e=>{let t=h(e);return e=>t(e)},c={at:h("at"),not:h("not"),any:h("any"),in:h("in"),fulltext:h("fulltext"),has:u("has"),missing:u("missing"),similar:(e=>{let t=h(e);return(...e)=>t("",...e)})("similar"),geopointNear:h("geopoint.near"),numberLessThan:h("number.lt"),numberGreaterThan:h("number.gt"),numberInRange:h("number.inRange"),dateAfter:h("date.after"),dateBefore:h("date.before"),dateBetween:h("date.between"),dateDayOfMonth:h("date.day-of-month"),dateDayOfMonthAfter:h("date.day-of-month-after"),dateDayOfMonthBefore:h("date.day-of-month-before"),dateDayOfWeek:h("date.day-of-week"),dateDayOfWeekAfter:h("date.day-of-week-after"),dateDayOfWeekBefore:h("date.day-of-week-before"),dateMonth:h("date.month"),dateMonthAfter:h("date.month-after"),dateMonthBefore:h("date.month-before"),dateYear:h("date.year"),dateHour:h("date.hour"),dateHourAfter:h("date.hour-after"),dateHourBefore:h("date.hour-before")},d=e=>c.at("document.tags",r(e));var f,p,y=Object.defineProperty,g=(e,t,s)=>t in e?y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,m=(e,t,s)=>g(e,"symbol"!=typeof t?t+"":t,s);class w extends Error{constructor(e="An invalid API response was returned",t,s){super(e),m(this,"url"),m(this,"response"),this.url=t,this.response=s}}let b=(e,t)=>{let s=e.find(e=>t(e));if(!s)throw new w("Ref could not be found.",void 0,void 0);return s},v=e=>b(e,e=>e.isMasterRef),R=(e,t)=>b(e,e=>e.id===t),P=(e,t)=>b(e,e=>e.label===t),A=e=>e.replace(/%3B/g,";"),F=e=>{let t;for(let s of e.split("; ")){let e=s.split("=");if("io.prismic.preview"===A(e[0]).replace(/%3D/g,"=")){t=A(e.slice(1).join("="));break}}return t},k=e=>e.replace(/(\n| )*( |{|})(\n| )*/gm,(e,t,s)=>s),S=e=>c.any("document.tags",r(e)),T=e=>c.at("document.type",e);class j extends w{}class D extends w{}class q extends w{}class I extends j{}class O extends j{}class E extends j{}class $ extends D{}let L={Any:"Any",Document:"Document",Media:"Media",Web:"Web"},B=e=>{var t;return{link_type:L.Document,id:e.id,uid:e.uid||void 0,type:e.type,tags:e.tags,lang:e.lang,url:null==e.url?void 0:e.url,slug:null==(t=e.slugs)?void 0:t[0],...e.data&&Object.keys(e.data).length>0?{data:e.data}:{}}},_=(e,...t)=>{let s;if(!e)return null;let r="link_type"in e?e:B(e),[i]=t;switch(s="function"==typeof i||null==i?{linkResolver:i}:{...i},r.link_type){case L.Media:case L.Web:return"url"in r?r.url:null;case L.Document:if("id"in r&&s.linkResolver){let e=s.linkResolver(r);if(null!=e)return e}if("url"in r&&r.url)return r.url;return null;case L.Any:default:return null}},x=e=>new Promise(t=>setTimeout(t,e)),M=({interval:e}={})=>{let t=[],s=!1,r=0,i=()=>{var e;!s&&t.length>0&&(null==(e=t.shift())||e(),s=!0)},a=()=>{s=!1,i()},n=async(t,s,i)=>{let n=Date.now()-r;e&&n<e&&await x(e-n);let o=(async()=>t(...i))();s(o);try{await o}catch{}r=Date.now(),a()},o=(e,r,a)=>{new Promise(e=>{t.push(e)}).then(n.bind(void 0,e,r,a)),(async()=>{await Promise.resolve(),s||i()})()};return(e,...t)=>new Promise(s=>{o(e,s,t)})};var C=Object.defineProperty,U=(e,t,s)=>t in e?C(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,N=(e,t,s)=>U(e,"symbol"!=typeof t?t+"":t,s);class J{constructor(e){if(N(this,"fetchFn"),N(this,"fetchOptions"),N(this,"queuedFetchJobs",{}),N(this,"dedupedFetchJobs",{}),this.fetchOptions=e.fetchOptions,"function"==typeof e.fetch)this.fetchFn=e.fetch;else if("function"==typeof globalThis.fetch)this.fetchFn=globalThis.fetch;else throw new w("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.",void 0,void 0);this.fetchFn===globalThis.fetch&&(this.fetchFn=this.fetchFn.bind(globalThis))}async fetch(e,t={}){var s,r,i,a,n;let o={...this.fetchOptions,...t.fetchOptions,headers:{...null==(s=this.fetchOptions)?void 0:s.headers,...null==(r=t.fetchOptions)?void 0:r.headers},signal:(null==(i=t.fetchOptions)?void 0:i.signal)||t.signal||(null==(a=this.fetchOptions)?void 0:a.signal)};return(null==(n=t.fetchOptions)?void 0:n.body)?this.queueFetch(e,o):this.dedupeFetch(e,o)}queueFetch(e,t={}){let s=new URL(e).hostname;return this.queuedFetchJobs[s]||(this.queuedFetchJobs[s]=M({interval:1500})),this.queuedFetchJobs[s](()=>this.createFetchJob(e,t))}dedupeFetch(e,t={}){let s;return this.dedupedFetchJobs[e]&&this.dedupedFetchJobs[e].has(t.signal)?s=this.dedupedFetchJobs[e].get(t.signal):(this.dedupedFetchJobs[e]=this.dedupedFetchJobs[e]||new Map,s=this.createFetchJob(e,t).finally(()=>{var s,r;null==(s=this.dedupedFetchJobs[e])||s.delete(t.signal),(null==(r=this.dedupedFetchJobs[e])?void 0:r.size)===0&&delete this.dedupedFetchJobs[e]}),this.dedupedFetchJobs[e].set(t.signal,s)),s}createFetchJob(e,t={}){return this.fetchFn(e,t).then(async e=>{let t,s;if(e.ok)try{t=await e.json()}catch{}else try{s=await e.text(),t=JSON.parse(s)}catch{}return{status:e.status,headers:e.headers,json:t,text:s}})}}let z={accessToken:"access_token"},W=e=>"string"==typeof e?e:"desc"===e.direction?`${e.field} desc`:e.field,H=(e,t)=>{let{filters:s,predicates:i,...a}=t,o=new URL("documents/search",`${e}/`);if(s)for(let e of r(s))o.searchParams.append("q",`[${e}]`);if(i)for(let e of r(i))o.searchParams.append("q",`[${e}]`);for(let e in a){let t=z[e]||e,s=a[e];if("orderings"===t){let e=a[t];if(null!=e){let t=r(e).map(e=>W(e)).join(",");s=`[${t}]`}}else"routes"===t&&"object"==typeof a[t]&&(s=JSON.stringify(r(a[t])));null!=s&&o.searchParams.set(t,r(s).join(","))}return o.searchParams.set("x-c",`js-${n}`),o.toString()},G=e=>/^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(e),Q=e=>{if(G(e))return`https://${e}.cdn.prismic.io/api/v2`;throw new w(`An invalid Prismic repository name was given: ${e}`,void 0,void 0)},Z=e=>{try{let t=new URL(e).hostname;if(t.endsWith("prismic.io")||t.endsWith("wroom.io")||t.endsWith("wroom.test"))return t.split(".")[0]}catch{}throw new w(`An invalid Prismic Document API endpoint was provided: ${e}`,void 0,void 0)},K=e=>{try{return new URL(e),!0}catch{return!1}};var V=Object.defineProperty,X=e=>{throw TypeError(e)},Y=(e,t,s)=>t in e?V(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,ee=(e,t,s)=>Y(e,"symbol"!=typeof t?t+"":t,s),et=(e,t,s)=>t.has(e)||X("Cannot "+s),es=(e,t,s)=>(et(e,t,"read from private field"),s?s.call(e):t.get(e)),er=(e,t,s)=>t.has(e)?X("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,s),ei=(e,t,s,r)=>(et(e,t,"write to private field"),r?r.call(e,s):t.set(e,s),s);!function(e){e.Master="Master",e.ReleaseID="ReleaseID",e.ReleaseLabel="ReleaseLabel",e.Manual="Manual"}(p||(p={}));class ea extends J{constructor(e,t={}){if(super(t),er(this,f),ee(this,"documentAPIEndpoint"),ee(this,"accessToken"),ee(this,"routes"),ee(this,"brokenRoute"),ee(this,"defaultParams"),ee(this,"refState",{mode:p.Master,autoPreviewsEnabled:!0}),ee(this,"cachedRepository"),ee(this,"cachedRepositoryExpiration",0),t.documentAPIEndpoint||K(e),K(e)){this.documentAPIEndpoint=e;try{this.repositoryName=Z(e)}catch(t){console.warn(`[@prismicio/client] A repository name could not be inferred from the provided endpoint (\`${e}\`). Some methods will be disabled. Create the client using a repository name to prevent this warning. For more details, see ${o("prefer-repository-name")}`)}}else this.documentAPIEndpoint=t.documentAPIEndpoint||Q(e),this.repositoryName=e;this.accessToken=t.accessToken,this.routes=t.routes,this.brokenRoute=t.brokenRoute,this.defaultParams=t.defaultParams,t.ref&&this.queryContentFromRef(t.ref),this.graphQLFetch=this.graphQLFetch.bind(this)}set repositoryName(e){ei(this,f,e)}get repositoryName(){if(!es(this,f))throw new w(`A repository name is required for this method but one could not be inferred from the provided API endpoint (\`${this.documentAPIEndpoint}\`). To fix this error, provide a repository name when creating the client. For more details, see ${o("prefer-repository-name")}`,void 0,void 0);return es(this,f)}set endpoint(e){this.documentAPIEndpoint=e}get endpoint(){return this.documentAPIEndpoint}enableAutoPreviews(){this.refState.autoPreviewsEnabled=!0}enableAutoPreviewsFromReq(e){this.refState.httpRequest=e,this.refState.autoPreviewsEnabled=!0}disableAutoPreviews(){this.refState.autoPreviewsEnabled=!1}async get(e){let{data:t}=await this._get(e);return t}async getFirst(e){var t;let s={...e};e&&e.page||(null==e?void 0:e.pageSize)||(s.pageSize=(null==(t=this.defaultParams)?void 0:t.pageSize)??1);let{data:r,url:i}=await this._get(s),a=r.results[0];if(a)return a;throw new D("No documents were returned",i,void 0)}async dangerouslyGetAll(e={}){var t;let s;let{limit:r=1/0,...i}=e,a={...i,pageSize:Math.min(r,i.pageSize||(null==(t=this.defaultParams)?void 0:t.pageSize)||100)},n=[];for(;(!s||s.next_page)&&n.length<r;){let e=s?s.page+1:void 0;s=await this.get({...a,page:e}),n.push(...s.results),s.next_page&&await new Promise(e=>setTimeout(e,500))}return n.slice(0,r)}async getByID(e,t){return await this.getFirst(i(t,c.at("document.id",e)))}async getByIDs(e,t){return await this.get(i(t,c.in("document.id",e)))}async getAllByIDs(e,t){return await this.dangerouslyGetAll(i(t,c.in("document.id",e)))}async getByUID(e,t,s){return await this.getFirst(i(s,[T(e),c.at(`my.${e}.uid`,t)]))}async getByUIDs(e,t,s){return await this.get(i(s,[T(e),c.in(`my.${e}.uid`,t)]))}async getAllByUIDs(e,t,s){return await this.dangerouslyGetAll(i(s,[T(e),c.in(`my.${e}.uid`,t)]))}async getSingle(e,t){return await this.getFirst(i(t,T(e)))}async getByType(e,t){return await this.get(i(t,T(e)))}async getAllByType(e,t){return await this.dangerouslyGetAll(i(t,T(e)))}async getByTag(e,t){return await this.get(i(t,S(e)))}async getAllByTag(e,t){return await this.dangerouslyGetAll(i(t,S(e)))}async getByEveryTag(e,t){return await this.get(i(t,d(e)))}async getAllByEveryTag(e,t){return await this.dangerouslyGetAll(i(t,d(e)))}async getBySomeTags(e,t){return await this.get(i(t,S(e)))}async getAllBySomeTags(e,t){return await this.dangerouslyGetAll(i(t,S(e)))}async getRepository(e){let t=new URL(this.documentAPIEndpoint);return this.accessToken&&t.searchParams.set("access_token",this.accessToken),await this.fetch(t.toString(),e)}async getRefs(e){return(await this.getRepository(e)).refs}async getRefByID(e,t){return R(await this.getRefs(t),e)}async getRefByLabel(e,t){return P(await this.getRefs(t),e)}async getMasterRef(e){return v(await this.getRefs(e))}async getReleases(e){return(await this.getRefs(e)).filter(e=>!e.isMasterRef)}async getReleaseByID(e,t){return R(await this.getReleases(t),e)}async getReleaseByLabel(e,t){return P(await this.getReleases(t),e)}async getTags(e){try{let t=await this.getCachedRepositoryForm("tags",e),s=new URL(t.action);return this.accessToken&&s.searchParams.set("access_token",this.accessToken),await this.fetch(s.toString(),e)}catch{return(await this.getRepository(e)).tags}}async buildQueryURL({signal:e,fetchOptions:t,...s}={}){let r=s.ref||await this.getResolvedRefString({signal:e,fetchOptions:t}),i=s.integrationFieldsRef||(await this.getCachedRepository({signal:e,fetchOptions:t})).integrationFieldsRef||void 0;return H(this.documentAPIEndpoint,{...this.defaultParams,...s,ref:r,integrationFieldsRef:i,routes:s.routes||this.routes,brokenRoute:s.brokenRoute||this.brokenRoute,accessToken:s.accessToken||this.accessToken})}async resolvePreviewURL(e){var t,s;let r=e.documentID,i=e.previewToken;if(void 0!==globalThis.location){let e=new URLSearchParams(globalThis.location.search);r=r||e.get("documentId"),i=i||e.get("token")}else if(this.refState.httpRequest){if("query"in this.refState.httpRequest)r=r||(null==(t=this.refState.httpRequest.query)?void 0:t.documentId),i=i||(null==(s=this.refState.httpRequest.query)?void 0:s.token);else if("url"in this.refState.httpRequest&&this.refState.httpRequest.url){let e=new URL(this.refState.httpRequest.url,"missing-host://").searchParams;r=r||e.get("documentId"),i=i||e.get("token")}}if(null!=r&&null!=i){let t=_(await this.getByID(r,{ref:i,lang:"*",signal:e.signal,fetchOptions:e.fetchOptions}),{linkResolver:e.linkResolver});if("string"==typeof t)return t}return e.defaultURL}queryLatestContent(){this.refState.mode=p.Master}queryContentFromReleaseByID(e){this.refState={...this.refState,mode:p.ReleaseID,releaseID:e}}queryContentFromReleaseByLabel(e){this.refState={...this.refState,mode:p.ReleaseLabel,releaseLabel:e}}queryContentFromRef(e){this.refState={...this.refState,mode:p.Manual,ref:e}}async graphQLFetch(e,t){let s=await this.getCachedRepository(),r=await this.getResolvedRefString(),i={"Prismic-ref":r,Authorization:this.accessToken?`Token ${this.accessToken}`:"",...t?t.headers:{}};s.integrationFieldsRef&&(i["Prismic-integration-field-ref"]=s.integrationFieldsRef);let a={};for(let e in i)i[e]&&(a[e.toLowerCase()]=i[e]);let n=new URL(e);n.searchParams.set("ref",r);let o=n.searchParams.get("query");return o&&n.searchParams.set("query",k(o)),await this.fetchFn(n.toString(),{...t,headers:a})}async getCachedRepository(e){return(!this.cachedRepository||Date.now()>=this.cachedRepositoryExpiration)&&(this.cachedRepositoryExpiration=Date.now()+5e3,this.cachedRepository=await this.getRepository(e)),this.cachedRepository}async getCachedRepositoryForm(e,t){let s=(await this.getCachedRepository(t)).forms[e];if(!s)throw new w(`Form with name "${e}" could not be found`,void 0,void 0);return s}async getResolvedRefString(e){var t,s;if(this.refState.autoPreviewsEnabled){let e,r;if((null==(t=this.refState.httpRequest)?void 0:t.headers)?"get"in this.refState.httpRequest.headers&&"function"==typeof this.refState.httpRequest.headers.get?r=this.refState.httpRequest.headers.get("cookie"):"cookie"in this.refState.httpRequest.headers&&(r=this.refState.httpRequest.headers.cookie):(null==(s=globalThis.document)?void 0:s.cookie)&&(r=globalThis.document.cookie),r&&(e=F(r)),e)return e}let r=await this.getCachedRepository(e),i=this.refState.mode;if(i===p.ReleaseID)return R(r.refs,this.refState.releaseID).ref;if(i===p.ReleaseLabel)return P(r.refs,this.refState.releaseLabel).ref;if(i===p.Manual){let e=await a(this.refState.ref)();if("string"==typeof e)return e}return v(r.refs).ref}async _get(e,t=0){var s,r;let i=await this.buildQueryURL(e);try{return{data:await this.fetch(i,e),url:i}}catch(l){if(!(l instanceof E||l instanceof O)||t>=2)throw l;(null==e?void 0:e.ref)||(this.cachedRepository=void 0);let a=null==(r=null==(s=l.message.match(/Master ref is: (?<ref>.*)$/))?void 0:s.groups)?void 0:r.ref;if(!a)throw l;let n=new URL(i).searchParams.get("ref"),o=l instanceof E?"invalid":"expired";return console.warn(`The ref (${n}) was ${o}. Now retrying with the latest master ref (${a}). If you were previewing content, the response will not include draft content.`),await this._get({...e,ref:a},t+1)}}async fetch(e,t={}){let s=await super.fetch(e,t);if(404!==s.status&&429!==s.status&&null==s.json)throw new w(void 0,e,s.json||s.text);switch(s.status){case 200:case 201:return s.json;case 400:throw new q(s.json.message,e,s.json);case 401:case 403:throw new j(s.json.error||s.json.message,e,s.json);case 404:if(void 0===s.json)throw new $(`Prismic repository not found. Check that "${this.documentAPIEndpoint}" is pointing to the correct repository.`,e,e.startsWith(this.documentAPIEndpoint)?void 0:s.text);if("api_notfound_error"===s.json.type)throw new E(s.json.message,e,s.json);if("api_security_error"===s.json.type&&/preview token.*expired/i.test(s.json.message))throw new I(s.json.message,e,s.json);throw new D(s.json.message,e,s.json);case 410:throw new O(s.json.message,e,s.json);case 429:{let r=Number(s.headers.get("retry-after")),i=Number.isNaN(r)?1e3:r;return await new Promise((s,r)=>{setTimeout(async()=>{try{s(await this.fetch(e,t))}catch(e){r(e)}},i)})}}throw new w(void 0,e,s.json)}}f=new WeakMap;let en=(e,t)=>new ea(e,t)}};